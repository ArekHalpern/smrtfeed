"use server";

import prisma from '@/lib/db/prisma';

export async function getPapers() {
  try {
    const papers = await prisma.paper.findMany({
      select: { id: true, title: true, datePublished: true },
      orderBy: { datePublished: 'desc' }
    });
    return papers;
  } catch (error) {
    console.error("Error fetching papers:", error);
    throw error;
  }
}

export async function getRandomPaperId() {
  try {
    const papersCount = await prisma.paper.count();
    const skip = Math.floor(Math.random() * papersCount);
    const randomPaper = await prisma.paper.findFirst({
      skip: skip,
      select: { id: true }
    });
    return randomPaper?.id || null;
  } catch (error) {
    console.error("Error fetching random paper:", error);
    throw error;
  }
}

export async function generateTweet(paperId: string) {
  console.log("generateTweet function called");
  try {
    const paper = await prisma.paper.findUnique({
      where: { id: paperId },
      select: { id: true, title: true, datePublished: true, url: true, authors: true, key_insights: true }
    });

    if (!paper) {
      throw new Error("Paper not found");
    }

    const paperTitle = paper.title;
    const datePublished = paper.datePublished.toISOString().split('T')[0]; // Format as YYYY-MM-DD
    const paperUrl = paper.url;
    const authors = (paper.authors as { name: string }[]).map(author => author.name).join(", ");
    console.log("Using paperId:", paperId);

    const apiUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/openai/create-insight`;
    console.log("Attempting to fetch from:", apiUrl);

    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ paperId }),
    });

    console.log("Response status:", response.status);

    const data = await response.json();

    if (!response.ok) {
      console.error("API response error:", response.status, data);
      throw new Error(`Failed to generate content: ${response.status} ${response.statusText}. Details: ${data.details || 'Unknown error'}`);
    }

    console.log("API response data:", data);

    if (!data.content) {
      console.error("Invalid API response:", data);
      throw new Error("Invalid API response: content not found in data");
    }

    // Return the structured content
    return `"${paperTitle}"
Published: ${datePublished}

Overview:
${data.content.summary}

Key Insights:
${data.content.keyInsights.map((insight: string, index: number) => `${index + 1}. ${insight}`).join('\n')}

Authors: ${authors}

URL: ${paperUrl}`;

  } catch (error) {
    console.error("Error generating insight:", error);
    throw error;
  }
}

// Add a new function to refresh insights
export async function refreshInsights(paperId: string) {
  try {
    const paper = await prisma.paper.findUnique({
      where: { id: paperId },
      select: { id: true, title: true, datePublished: true, url: true, authors: true }
    });

    if (!paper) {
      throw new Error("Paper not found");
    }

    const apiUrl = `${process.env.NEXT_PUBLIC_SITE_URL}/api/openai/refresh-insight`;
    
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ paperId }),
    });

    if (!response.ok) {
      throw new Error(`Failed to refresh insights: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();

    if (!data.content) {
      throw new Error("Invalid API response: content not found in data");
    }

    // Parse authors from the paper object
    const authors = (paper.authors as { name: string }[]).map(author => author.name).join(", ");

    // Format the content into a tweet-like structure with line breaks
    const refreshedTweet = `"${paper.title}"\nPublished: ${paper.datePublished.toISOString().split('T')[0]}\n\nUpdated Key Insights:\n${data.content.keyInsights.map((insight: string, index: number) => `${index + 1}. ${insight}`).join('\n')}\n\nAuthors: ${authors}\n\nURL: ${paper.url}\n\nOverview Generated By SmrtFeed AI`;

    return refreshedTweet;
  } catch (error) {
    console.error("Error refreshing insights:", error);
    throw error;
  }
}

export async function getPaperInsight(paperId: string) {
  try {
    const paper = await prisma.paper.findUnique({
      where: { id: paperId },
      select: {
        id: true,
        title: true,
        datePublished: true,
        url: true,
        authors: true,
        conclusion: true,
        key_insights: true,
      }
    });

    if (!paper) {
      throw new Error("Paper not found");
    }

    const authors = (paper.authors as { name: string }[]).map(author => author.name).join(", ");
    const keyInsights = Array.isArray(paper.key_insights)
      ? paper.key_insights
          .filter((insight): insight is { description: string } => 
            typeof insight === 'object' && insight !== null && 'description' in insight)
          .map(insight => insight.description)
          .slice(0, 5)
      : [];

    return {
      id: paper.id,
      title: paper.title,
      datePublished: paper.datePublished.toISOString().split('T')[0],
      content: {
        summary: paper.conclusion || "No summary available.",
        keyInsights: keyInsights,
      },
      authors: authors,
      url: paper.url || "",
    };
  } catch (error) {
    console.error("Error fetching paper insight:", error);
    throw error;
  }
}
